{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"StarDist - Object Detection with Star-Convex Polygons","text":"<p>This web site provides answers to frequently asked questions (FAQ) when using StarDist.</p> <p>Please visit the main stardist project page for general documentation, installation instructions, and issue reports. </p> <p>If you are using StarDist in your research please cite the relevant paper(s):</p> <pre><code>@inproceedings{schmidt2018,\n  author    = {Uwe Schmidt and Martin Weigert and Coleman Broaddus and Gene Myers},\n  title     = {Cell Detection with Star-Convex Polygons},\n  booktitle = {Medical Image Computing and Computer Assisted Intervention - {MICCAI} \n  2018 - 21st International Conference, Granada, Spain, September 16-20, 2018, Proceedings, Part {II}},\n  pages     = {265--273},\n  year      = {2018},\n  doi       = {10.1007/978-3-030-00934-2_30}\n}\n\n@inproceedings{weigert2020,\n  author    = {Martin Weigert and Uwe Schmidt and Robert Haase and Ko Sugawara and Gene Myers},\n  title     = {Star-convex Polyhedra for 3D Object Detection and Segmentation in Microscopy},\n  booktitle = {The IEEE Winter Conference on Applications of Computer Vision (WACV)},\n  month     = {March},\n  year      = {2020},\n  doi       = {10.1109/WACV45572.2020.9093435}\n}\n\n@inproceedings{weigert2022,\n  author    = {Martin Weigert and Uwe Schmidt},\n  title     = {Nuclei Instance Segmentation and Classification in Histopathology Images with Stardist},\n  booktitle = {The IEEE International Symposium on Biomedical Imaging Challenges (ISBIC)},\n  year      = {2022},\n  doi       = {10.1109/ISBIC56247.2022.9854534}\n}\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#data","title":"Data","text":""},{"location":"faq/#will-it-work-for-my-data-application","title":"Will it work for my data/application?","text":""},{"location":"faq/#how-do-i-know-if-my-objects-of-interest-are-sufficiently-star-convex-i-e-is-stardist-a-good-choice-for-my-data","title":"How do I know if my objects of interest are (sufficiently) star-convex, i.e. is StarDist a good choice for my data?","text":"<p>In a nutshell, most blob-like object shapes are star-convex (see Wikipedia article). If you have labeled images, you can load your data in our example notebooks and see how well it can be reconstructed with a star-convex polygon/polyhedron representation. An average reconstruction IoU score (mean intersection of union score) of 0.8 or higher could be generally considered good enough.</p>"},{"location":"faq/#other-stains-markers-with-different-appearance-quality-or-inhomogeneity","title":"Other stains/markers with different appearance, quality, or inhomogeneity?","text":"<p>Please first verify that the shapes of your objects are star-convex, i.e. blob-like. Examples of objects (segmentable by StarDist) include cells in brightfield images and stained structures in fluorescence or histology images. Where stains are used, an object can have its whole area stained, just its boundary stained, or be negatively stained (i.e. it is dark compared to other regions of the image). Next, please check if one of the pretrained models works for your data.</p> <p>If your data is suitable for StarDist, but there is no pretrained model available, you need to train your own model. To that end, you need labeled images before you can train your model (you can use the provided example notebooks where you replace the example data with your own).</p>"},{"location":"faq/#can-other-objects-besides-round-nuclei-be-segmented-e-g-multi-lobe-nuclei-granules-bacteria","title":"Can other objects besides round nuclei be segmented (e.g. multi-lobe nuclei, granules, bacteria)?","text":"<p>The short answer is that StarDist should work well for segmenting all kinds of blob-like objects with a star-convex shape. However, it typically performs quite a bit better for roundish shapes compared to strongly elongated ones. For the latter, you often need to increase the number of rays to get decent results.</p>"},{"location":"faq/#with-multiple-nucleus-types-is-it-possible-to-only-segment-some-or-classify-in-addition-to-segmentation","title":"With multiple nucleus types, is it possible to only segment some or classify in addition to segmentation?","text":"<p>If there are multiple object/cell types in your image and you only want to segment some of them, you have two options:</p> <ol> <li> <p>Annotate only the object type(s) of interest in your training data, implicitly telling StarDist to consider everything else as background. While this can work, it might make it more difficult for StarDist to reliably distinguish between objects and background, especially if the visual differences between object types are subtle.</p> </li> <li> <p>Annotate all objects in the training data and additionally provide a class label for each annotated object. This will allow you to train a StarDist model that can additionally classify all objects while segmenting them. This feature is supported for 2D and 3D images since StarDist version 0.7.0. Please see this example notebook (using 2D images) for more details.</p> </li> </ol>"},{"location":"faq/#use-for-cell-counting-or-centroid-localization","title":"Use for cell counting or centroid localization?","text":"<p>If you just want to count or localize the centroids of cells, it might be a bit overkill to use StarDist (although trying one of the pretrained models is always a good idea). Dedicated cell counting and centroid localization approaches do exist, and they often need weaker forms of labeling, such as cell counts per training image or point annotations for cell centroids. However, if such centroid localization methods yield suboptimal results (e.g. in the case of very densely packed cells/nuclei) it might be worth to spend the extra annotation effort and train a dedicated StarDist model.</p>"},{"location":"faq/#data-format-pre-processing","title":"Data format/pre-processing","text":""},{"location":"faq/#do-i-need-to-pre-process-my-images-e-g-background-subtraction-filtering","title":"Do I need to pre-process my images (e.g. background subtraction, filtering)?","text":"<p>In general, special pre-processing of images (such as background subtraction, denoising, etc) is not necessary. However it is reasonable to scale your input images such that the overall size of objects (in pixels) is similar to the size of objects used during training. If you have trained your own model, that means to always ensure that new images have roughly the same pixel size as the training images. This will make it much easier for StarDist to learn and might also avoid erroneous predictions of objects that are either too small or too large.</p> <p>If you are using a pre-trained model, it is important to know what kind of images it was trained with to understand if your image data is similar enough. In some cases, you can pre-process your images to make them suitable for a pre-trained model (e.g. up/downscaling of the image).</p> <p>Note that you can use the optional parameter <code>scale</code> when calling <code>model.predict_instances</code> instead of manually rescaling your images before prediction.</p>"},{"location":"faq/#is-it-advantageous-to-preprocess-3d-stacks-to-adjust-the-axial-resolution","title":"Is it advantageous to preprocess 3D stacks to adjust the axial resolution?","text":"<p>If your images contain only very few (&lt;10) axial planes, you might consider doing a 2D segmentation from a maximum intensity projection (MIP) of the 3D stack. But the MIP should only be one or two cell layers thick. If you can't individualize cells by eye, there is little hope that StarDist will get it right.</p> <p>If you need 3D segmentations, StarDist 3D does support anisotropic data (e.g. a 5x larger axial vs lateral pixel size should not be a problem). However, we sometimes found it advantageous to upscale the axial resolution to make objects appear more isotropic in the images. Hence, first try it directly with the anisotropic data and only if that doesn't lead to good results you could upscale the data isotropically. Note, that as one is not interested in restoring the image intensity signal but rather only segmenting the objects, it most likely would not make sense to use Isotropic CARE.</p>"},{"location":"faq/#is-a-specific-image-format-size-or-normalization-required","title":"Is a specific image format, size, or normalization required?","text":"<p>StarDist is in general not limited to images of specific formats, bit-depths, or sizes. Any input image however needs to be normalized to floating point values roughly in the range 0..1 before network prediction. Our example notebooks demonstrate how this normalization is done in Python, and our plugins (Fiji, napari) do this by default.</p> <p>StarDist can be trained and predict on images with arbitrary spatial dimensions, but once a model is trained it is limited to its specific number of input channels (e.g. one cannot use a model trained for 2D RGB images on 2D single channel images).</p> <p>StarDist does not put any constraints on the specific size of the input image: all padding and cropping necessary for the actual neural network is automatically handled for you. Also note that StarDist can do tiled prediction of large images in case of limited GPU memory. Furthermore, there is a special prediction mode for huge images that may not even fit into CPU memory (see example notebook).</p>"},{"location":"faq/#are-multi-channel-images-supported","title":"Are multi-channel images supported?","text":"<p>A StarDist model is always trained to work for images with specific input channels in a given order. On one hand, that means you can train your own model with any number of input channels that you think might be helpful to accurately segment your images. On the other hand, these channels have to be always present in images that you want to segment using this model. Note that this also applies to the pretrained models that we provide, which expect images with specific input channels.</p> <p>If images have additional channels or channels in a different order than expected by a trained StarDist model, you first need to re-arrange them. For example, you may need to split the image channels and select the appropriate channel image (e.g. DAPI) before you can apply our  pretrained model for fluorescent nuclei in Fiji. You can then use the resulting segmentation to perform measurements in the other channels.</p>"},{"location":"faq/#what-if-my-training-dataset-does-not-fit-into-cpu-memory","title":"What if my training dataset does not fit into (CPU) memory?","text":"<p>If you cannot load your full training data into CPU memory (e.g. when using many large annotated 3D volumes), you can do the following:</p> <ol> <li>Use a Keras <code>Sequence</code>/<code>PyDataset</code> to lazily load your images and masks.</li> <li>Disable sample caching in the config, e.g. <code>config = Config3D(..., train_sample_cache = False)</code>.</li> <li>Use <code>model.train(X,Y,...)</code> with <code>X</code> and <code>Y</code> now being Keras <code>Sequence</code>/<code>PyDataset</code> objects.</li> </ol> <p>This should lead to an almost constant memory footprint during training.</p>"},{"location":"faq/#labeling-annotation","title":"Labeling/annotation","text":""},{"location":"faq/#how-to-label","title":"How to label","text":""},{"location":"faq/#should-i-annotate-a-few-entire-raw-images-stacks-or-is-it-better-to-annotate-several-smaller-image-crops","title":"Should I annotate a few entire raw images/stacks, or is it better to annotate several smaller image crops?","text":"<p>In general, it is better to annotate several image crops instead of entire (big) images or stacks. It is important that the content within annotated training images is representative of the content within images that you want to predict on later, after the model has been trained. In other words, the training data should cover the full range of variability that you expect in your (future) data.</p>"},{"location":"faq/#which-size-should-the-training-images-be","title":"Which size should the training images be?","text":"<p>As mentioned earlier, it is generally better to annotate a variety of image crops as your training data. However, those crops must be big enough to contain entire fully visible objects and provide some context around them. Also make sure that not too many of the annotated objects are touching the border (it's fine if some do, but it should not be the majority). Example: if you have small cells with a diameter of 20 pixels, it might be sufficient to have annotated images of size 160x160, whereas if your objects have a diameter of 80 pixels, you would need to use larger annotated images e.g. of size 512x512. </p> <p>The \"patch size\" is an important parameter for training StarDist, and the size of images used for training affects what an appropriate value for the patch size should be (to maintain compatibility with the neural network architecture). For example, the patch size used for training StarDist must be smaller or equal than the size of the smallest annotated training image. To be on the safe side, ensure that the patch size is divisible by 16 along all dimensions. For example, you can annotate image crops of 300x300 pixels and then use a patch size of 256x256 pixels for training.</p>"},{"location":"faq/#is-there-an-upper-size-limit-for-objects-to-be-well-segmented","title":"Is there an upper size limit for objects to be well segmented?","text":"<p>The maximal size of objects that can be well segmented depends on the receptive field of the neural network used inside a StarDist model.</p> <p>For the default StarDist 2D network configuration (U-Net with depth 3), this is roughly 90 pixels. If your objects are larger than this and the segmentation results indicate over-segmentation, you can either a) downscale your input images such that the object size becomes smaller, or b) increase the receptive field of a StarDist model by changing the grid parameter in the model configuration (e.g. setting <code>grid=(2,2)</code> will roughly double the receptive field). Grid values of 4 and even 8 do make sense for images with a large minimum object size, e.g. 5x the size of the grid value.</p> <p>This is similar for StarDist 3D, although the receptive field for the default network configuration (U-Net with depth 2) is only roughly 45 pixels. Besides downscaling your input images, you can also change the grid parameter as mentioned above, but do not increase it for Z if you have strongly anisotropic images with relatively few axial planes, e.g. use <code>grid=(1,2,2)</code>.</p> <p>Of course, in both cases you can also increase the depth of the U-Net network (via parameter <code>unet_n_depth</code>), but keep in mind that this can lead to more overfitting (i.e. the learned model might not generalize well to new images), especially when training with small datasets.</p>"},{"location":"faq/#do-i-have-to-annotate-all-nuclei-objects-in-a-training-image-what-about-those-that-are-only-partially-visible-what-about-other-objects-not-of-interest","title":"Do I have to annotate all nuclei (objects) in a training image? What about those that are only partially visible? What about other objects not of interest?","text":"<p>Sparse labelling was not supported until recently, i.e. you had to label all the objects in your chosen training images, even if they were only partially visible. If you didn't do this, the trained model could've been confused as to which pixels belong to objects and which belong to the background. As a consequence, this might have resulted in many objects being missed during prediction.</p> <p>As of StarDist 0.9.0, we do support sparse labelling, i.e. it is no longer necessary to label every pixel in the training images. Concretely, unlabeled pixels must be given a negative integer value (e.g. -1) to indicate that training should ignore these pixels. However, you should use this to either label every pixel of an individual object or none, i.e. a labeled object must not have any \"holes\" of unlabeled pixels.</p> <p>Please refer to this on how to deal with other roundish objects which are also present in the image but are not of interest to you.</p>"},{"location":"faq/#is-it-better-to-annotate-images-from-scratch-or-to-bootstrap-curate-imperfect-annotations-e-g-from-another-method-is-training-sensitive-to-annotation-mistakes","title":"Is it better to annotate images from scratch or to bootstrap/curate imperfect annotations (e.g. from another method)? Is training sensitive to annotation mistakes?","text":"<p>In practice, you probably would like to use the labeling approach that requires the least amount of manual annotation/curation work. It depends on your data whether this is labeling from scratch or curating an imperfect automatic labeling.</p> <p>Annotating images from scratch is often easier because it doesn't involve obtaining predictions and curating them. It can be a good strategy if the task is not too difficult.</p> <p>If you already have an instance segmentation method with decent results, you can try training StarDist by using its predictions as ground truth. As long as there are no systematic mistakes in the ground truth, we have observed that training can still be successful. Especially when the segmentation task is more difficult (e.g. noisy images and/or strong appearance variations), it often makes sense to train an initial model, curate its predictions and add them to the training data.</p>"},{"location":"faq/#how-many-images-or-nucleus-object-instances-do-i-have-to-annotate-for-good-results","title":"How many images or nucleus (object) instances do I have to annotate for good results?","text":"<p>This is very difficult to answer in general, since it really depends on your specific data. The more variability is in your data (object shapes and packing, background, noise, signal variation, aberrations), the more training data (in form of a wide range of examples) is necessary so that the network can learn to perform accurate predictions.</p> <p>We have often seen good results from as few as 5-10 image crops each having 10-20 annotated objects (in 2D), but your mileage may vary substantially. You can always start with a small training dataset, inspect/curate the results and iterate. </p> <p>Furthermore, one can/should always use data augmentation to artificially inflate the training data by adding training images with plausible appearance variations. What plausible means depends on the data at hand, but some operations (random flips and rotations, intensity shifts) can be used in most cases and are demonstrated e.g. in the training example notebook. </p>"},{"location":"faq/#software-format-for-labeling","title":"Software/format for labeling","text":""},{"location":"faq/#in-which-format-do-i-need-to-save-my-image-annotations","title":"In which format do I need to save my image annotations?","text":"<p>The image annotations (also known as label images or label masks) should be integer-valued (e.g. 8-bit, 16-bit, 32-bit) TIFF files where all background pixels have value 0 and each object instance is represented by an area/volume filled with a unique positive integer value. It does not matter what the values are and they do not need to be consecutive. Please note that a foreground/background segmentation mask, where all object instances are denoted by the same value, is not sufficient for StarDist training.</p> <p>Note that for visualization purposes, label images are often displayed with each object instance in a different color (to tell them apart) on a black background; this is the result of applying a look-up table (e.g. Glasbey on dark in Fiji). As mentioned above, the label masks for StarDist must be integer-valued TIFF files and not RGB files, i.e. the specific color does not matter.</p>"},{"location":"faq/#which-software-do-you-recommend-to-annotate-2d-and-3d-images","title":"Which software do you recommend to annotate 2D and 3D images?","text":"<p>In 2D, there are several options, among them being Fiji, QuPath, napari, or Labkit. Although each of these provide decent annotation tools, we currently recommend using Labkit for its easy label export. Please read here for more detailed instructions how to use Labkit to generate annotations.  </p> <p>In 3D, there are fewer options: Labkit and Paintera (the latter being very sophisticated but having a steeper learning curve).</p>"},{"location":"faq/#i-ve-annotated-my-images-in-software-x-how-do-i-export-the-annotations-as-label-images","title":"I've annotated my images in software X, how do I export the annotations as label images?","text":"<p>Here is some advice for exporting annotations to a label image from different tools (see here for a list of recommended tools). </p> <ul> <li>Fiji: Use this script to convert annotations to label images.</li> <li>Labkit: Please read this.</li> <li>QuPath: See this post to get started.</li> </ul>"},{"location":"faq/#using-pretrained-models","title":"Using pretrained models","text":""},{"location":"faq/#how-do-i-know-if-a-pretrained-or-any-model-is-suitable-good-enough-for-my-data","title":"How do I know if a pretrained (or any) model is suitable/good enough for my data?","text":"<p>First, you can take a look at the existing pretrained models and inspect the images they were trained on, to get an idea if one of them might be suitable for your data. At the moment, you can find an overview of pretrained models here and here, including links to the training datasets. Furthermore, our example notebooks also demonstrate how to show a list of the available pretrained models.</p> <p>If you found a promising pretrained model for your data, it is probably easiest to quickly try it out with our napari plugin or Fiji plugin and manually inspect if the results are plausible. If that's the case, you may also want to quantitatively evaluate the results.</p> <p>Furthermore, you might find additional models in the BioImage Model Zoo (bioimage.io). See this example notebook on how to import (and export) a bioimage.io model.</p>"},{"location":"faq/#do-i-need-to-rescale-my-images-how-do-i-know-which-pixel-resolution-is-required","title":"Do I need to rescale my images? How do I know which pixel resolution is required?","text":"<p>Besides being rather robust to intensity changes, our pretrained models are able to segment objects with a fair range of sizes. Please take a look at the respective training datasets to get an idea of the object size variations that the model should be able handle. In the future, we might provide additional metadata for each pretrained model to help you with that. Also please have a look at this related question.</p> <p>If your images contain relatively large objects and you observe lots of over-segmentation mistakes (i.e. several smaller objects predicted instead of an expected large one), you should try to reduce the pixel resolution of the image before applying StarDist. The easiest way to do that is to use the parameter <code>scale</code> when calling <code>model.predict_instances</code>.</p>"},{"location":"faq/#is-there-a-pretrained-model-for-3d-or-do-you-plan-to-release-one","title":"Is there a pretrained model for 3D, or do you plan to release one?","text":"<p>Unfortunately not, but we would like to provide one at some point. A major issue is the lack of available training data.</p>"},{"location":"faq/#do-you-have-plans-to-release-other-pretrained-models","title":"Do you have plans to release other pretrained models?","text":"<p>There are no immediate plans at the moment, but we can relatively easily be persuaded to add new ones given a common use case and the availability of suitable training data.</p> <p>You might also find additional models at the BioImage Model Zoo (bioimage.io).</p>"},{"location":"faq/#speed-hardware-gpu","title":"Speed/Hardware/GPU","text":""},{"location":"faq/#how-can-i-speed-up-the-prediction-is-it-possible-to-predict-on-very-large-images-stacks","title":"How can I speed up the prediction? Is it possible to predict on very large images/stacks?","text":"<p>StarDist prediction consists of two phases:</p> <ol> <li> <p>Neural network prediction based on a normalized input image. This can optionally be GPU-accelerated (in both Python and Fiji) if TensorFlow with the necessary dependencies is installed. (GPU acceleration is very much recommended for 3D images and large 2D images.)</p> </li> <li> <p>Post-processing of the neural network output, which involves a non-maximum suppression step (using the provided probability and overlap thresholds) to prune redundant object instances. This step does not use the GPU (and cannot reasonably be changed to do so), but will take advantage of all available CPU cores, i.e. can be substantially faster on more powerful multi-core CPUs. StarDist was properly installed with multi-core (OpenMP) support if it is running on several CPU cores while predicting.</p> </li> </ol> <p>In order to handle large images (or stacks) that cannot be processed all at once in step 1, there is an option to internally process the input image in separate overlapping tiles. To that end, you can specify the number of tiles in both Python (parameter <code>n_tiles</code> of <code>model.predict</code>) and Fiji. This is especially necessary because GPUs often have limited memory that does not permit to process large images directly.</p> <p>Step 2 is currently processed for the entire image, which can be a bottleneck for huge images in terms of computation and memory. Therefore, there is a special prediction mode that jointly does both steps in overlapping blocks and additionally doesn't even require the whole input image (and label image output) to be loaded into CPU memory all at once (see example notebook).</p>"},{"location":"faq/#what-hardware-do-you-recommend","title":"What hardware do you recommend?","text":"<p>If you occasionally want to segment 2D images of moderate size (e.g. 1024x1024 pixels), you do not need special hardware \u2013 a typical laptop will be enough. However, as mentioned before, both a more powerful multi-core CPU and a recent GPU can substantially speed up prediction with StarDist. Furthermore, training your own model without a GPU is not recommended at all, as this can be very slow, especially for 3D images. Of course, if you intend to use StarDist for large images or stacks, you will need a sufficient amount of RAM and storage.</p> <p>Regarding the choice of GPU, it (currently) has to be a CUDA-compatible GPU from Nvidia. There are many options to choose from, which do change all the time. A very important factor besides speed is the amount of GPU memory, which should be 8 GB or more when training StarDist 3D models. It is much less important for 2D training and prediction (in both 2D and 3D).</p>"},{"location":"faq/#method-technical","title":"Method/technical","text":""},{"location":"faq/#what-are-the-probability-and-overlap-nms-thresholds-how-do-i-select-good-values","title":"What are the probability and overlap/NMS thresholds? How do I select good values?","text":"<p>StarDist internally uses a neural network to predict two separate quantities per pixel, 1) an object probability and 2) several distances to the object boundary that the pixel belongs to. Only pixels with an object probability above a chosen probability threshold are allowed to \"vote\" for an object candidate (i.e. a star-convex polygon defined via the predicted distances). Note that many pixels will vote for similar object candidates, since they belong to the same object. Hence, after all object candidates have been collected, a non-maximum suppression (NMS) step is used to prune all the redundant objects, such that (ideally) only one object is retained for every true object in the image. To that end, we need to define which object candidates likely represent the same object in the image. We use a typical approach by defining object similarity in terms of overlap, i.e. two objects are considered equal if their (normalized) intersection area/volume exceeds an overlap/NMS threshold.</p> <p>At the end of our training notebooks, we automatically optimize both thresholds based on your validation data, such that they should yield good results in many cases. However, both thresholds can be adjusted to your specific application. Higher values of the probability threshold can yield fewer segmented objects, but will likely avoid false positives. Higher values of the overlap threshold will allow segmented objects to overlap more. If your objects should never overlap, you may set the overlap threshold close to 0. </p>"},{"location":"faq/#how-does-it-work-under-the-hood-i-want-to-know-technical-details","title":"How does it work under the hood? I want to know technical details.","text":"<p>Please see the high-level overview above. If you want to know more, please have a look at our documentation and the papers:</p> <ul> <li> <p>Uwe Schmidt, Martin Weigert, Coleman Broaddus, and Gene Myers. Cell Detection with Star-convex Polygons. International Conference on Medical Image Computing and Computer-Assisted Intervention (MICCAI), Granada, Spain, September 2018.</p> </li> <li> <p>Martin Weigert, Uwe Schmidt, Robert Haase, Ko Sugawara, and Gene Myers. Star-convex Polyhedra for 3D Object Detection and Segmentation in Microscopy. The IEEE Winter Conference on Applications of Computer Vision (WACV), Snowmass Village, Colorado, March 2020</p> </li> <li> <p>Martin Weigert and Uwe Schmidt. Nuclei Instance Segmentation and Classification in Histopathology Images with Stardist. The IEEE International Symposium on Biomedical Imaging Challenges (ISBIC), Kolkata, India, March 2022.</p> </li> </ul>"},{"location":"faq/#is-a-trained-model-sensitive-to-changes-in-image-intensity-or-object-size-as-compared-to-the-training-images","title":"Is a trained model sensitive to changes in image intensity or object size (as compared to the training images)?","text":"<p>A trained model will typically only work well for images that are similar to those that the model was trained on. However, one can use data augmentation during training to synthetically vary image intensities and object sizes. As a result, the trained model will be robust towards these variations, since it was trained to expect these. Also see this previous question.</p>"},{"location":"faq/#do-you-support-or-recommend-transfer-learning","title":"Do you support or recommend \"transfer learning\"?","text":"<p>While transfer learning is promising in case of limited annotated training data, we currently do not support it because we haven't investigated how and when to use it. (However, it is possible with the current code, but simply not documented, see this forum thread.)</p> <p>Furthermore, we have made the observation that training (from scratch) using a combination of a small custom dataset together with an existing bigger (and somewhat similar) dataset can also lead to better results than just training with the custom data.</p>"},{"location":"faq/#postprocessing-quantification","title":"Postprocessing/quantification","text":""},{"location":"faq/#is-it-possible-to-refine-the-shape-of-the-predicted-objects-e-g-for-not-fully-star-convex-objects","title":"Is it possible to \"refine\" the shape of the predicted objects (e.g. for not fully star-convex objects)?","text":"<p>It is possible, but not supported in our software at the moment. However, some people have already used StarDist to generate high-quality seeds and then used other seed-based methods (e.g. watershed) to obtain instance segmentations that are not restricted to star-convex object shapes.</p> <p>We also used an experimental 2D shape refinement approach when we participated in the CoNIC 2022 challenge. The approach is documented in the paper Nuclei Instance Segmentation and Classification in Histopathology Images with Stardist and also contains a link to the experimental code.</p> <p>We might have a production-ready solution in the future but can't promise if and when one will be available.</p>"},{"location":"faq/#how-do-i-evaluate-the-quality-of-the-predicted-results-of-a-model","title":"How do I evaluate the quality of the predicted results of a model?","text":"<p>Ultimately, this depends on your application, i.e. what you want to do with the segmentation results (e.g. counting, intensity measurements, tracking). Hence, we consider a typical evaluation approach here, which we also carry out at the end of our training notebooks.</p> <p>The detection/segmentation performance can be quantitatively evaluated by considering objects in the ground truth to be correctly matched if there are predicted objects with overlap (intersection over union (IoU)) beyond a chosen IoU threshold (value between 0 and 1). The obtained matching statistics (accuracy, recall, precision, etc.) can be quite informative for the model's performance (see sensitivity and specificity for further details). The IoU threshold can be between 0 (even slightly overlapping objects count as correctly predicted) and 1 (only pixel-perfectly overlapping objects count) and which threshold to use depends on the needed segmentation precision/application.</p>"},{"location":"faq/#how-can-i-perform-measurements-of-the-predicted-objects-in-software-x","title":"How can I perform measurements of the predicted objects in software X?","text":"<p>The output of StarDist is a label image and/or a list of (polygon/polyhedron) ROIs, one for each object. These can be used for quantification, for example:</p> <ul> <li> <p>Python: Based on the label image, the function regionprops (or regionprops_table) from scikit-image offers many different measurements for each object instance. Note that you can also export 2D predictions as ImageJ ROIs.</p> </li> <li> <p>Fiji/ImageJ: The ROI Manager can be used to measure many different properties (which can be chosen via Analyze &gt; Set Measurements...)</p> </li> </ul>"},{"location":"faq/#how-can-i-import-the-predicted-results-into-software-x","title":"How can I import the predicted results into software X?","text":"<p>As mentioned above, StarDist can output its predictions as label images, or lists of polygon/polyhedron coordinates. Label images are quite universal and can be imported in many different software packages. In Python, the 2D polygon coordinates can also be exported as ImageJ ROIs, or be serialized to different formats via Shapely. The 3D predictions can also be exported as meshes via <code>obj</code> files (see this).</p>"},{"location":"faq/#fiji-imagej","title":"Fiji/ImageJ","text":""},{"location":"faq/#after-training-in-python-how-do-i-export-a-model-to-be-used-in-fiji-do-i-have-to-be-careful-with-the-version-of-tensorflow","title":"After training in Python, how do I export a model to be used in Fiji? Do I have to be careful with the version of TensorFlow?","text":"<p>After training your StarDist model in Python, you can export it to be used in Fiji (or QuPath) by calling <code>model.export_TF()</code>. This will create a ZIP file that contains the trained model in the correct format.</p> <p>It is important that the version of TensorFlow (a neural network library that StarDist depends on) used in Fiji (or QuPath) is the same or newer as in Python. You can find out which version is used in Python via <code>import tensorflow; print(tensorflow.__version__)</code>. In Fiji, you can manage your version of TensorFlow via Edit &gt; Options &gt; TensorFlow.... Note that this also applies to our pretrained models, which currently require TensorFlow 1.12.0 or newer. </p> <p>Note that StarDist currently only supports TensorFlow 1.x, i.e. do not upgrade or install a recent 2.x version. Starting with version 0.6.0, StarDist for Python does work with either TensorFlow 1 or 2. Furthermore, when using TensorFlow 2, it appears that an exported model will work in Fiji with TensorFlow 1.14.0. We recommend to follow this approach to export your model.</p>"},{"location":"faq/#can-it-be-used-in-deepimagej","title":"Can it be used in DeepImageJ?","text":"<p>We recommend using our plugin when using StarDist in Fiji, because it bundles all the necessary steps.</p> <p>However, if you are an advanced user and want to use DeepImageJ, you should be able to do so with a pretrained or exported model. However, this will only perform the neural network prediction and not the necessary non-maximum suppression (NMS) step. You can call just the NMS step from our plugin (Plugins &gt; StarDist &gt; Other &gt; StarDist 2D NMS (postprocessing only)) though. Note that we haven't tested this workflow, but it should work in principle. Additionally, DeepImageJ can also run StarDist models from bioimage.io.</p>"},{"location":"faq/#the-fiji-plugin-currently-only-supports-2d-images-is-3d-support-planned","title":"The Fiji plugin currently only supports 2D images. Is 3D support planned?","text":"<p>Yes, we also want to support 3D in our Fiji plugin. However, there are some issues that we need to solve first, especially related to deployment (reliance on C++ code that isn't easily portable to Java).</p>"},{"location":"faq/#are-there-differences-between-the-python-and-fiji-versions","title":"Are there differences between the Python and Fiji versions?","text":"<p>Regarding the prediction results of the neural network, they should be identical or only have negligible differences. However, our Python package is the reference implementation with the most features, some of which are missing in Fiji.</p> <p>For example, besides lacking model training and 3D support, the Fiji plugin currently does not offer different normalization options for multi-channel images or quantitative evaluation of prediction results.</p> <p>Our napari plugin is a more full-featured alternative to the Fiji plugin, including 3D support.</p>"}]}